import { BehaviorSubject } from 'rxjs/BehaviorSubject';
import { Injectable, Optional, ChangeDetectionStrategy, Component, ChangeDetectorRef, EventEmitter, Input, NgZone, Output, NgModule } from '@angular/core';
import { trigger, animate, style, transition, query, stagger, keyframes } from '@angular/animations';
import { CommonModule } from '@angular/common';
import { NgxTranslationsModule } from '@stanvanheumen/ngx-translations';

const NotificationType = {
    Success: 'success',
    Error: 'error',
    Warning: 'warning',
    Info: 'info',
};
class NotificationOptions {
}

class NotificationsService {
    constructor(options) {
        this.options = options;
        this.defaultTitles = {
            [NotificationType.Success]: 'Action was successful',
            [NotificationType.Error]: 'Action did fail',
            [NotificationType.Warning]: 'Warning',
            [NotificationType.Info]: 'Information'
        };
        this.defaultIcons = {
            [NotificationType.Success]: 'check_circle',
            [NotificationType.Error]: 'error_outline',
            [NotificationType.Warning]: 'error_outline',
            [NotificationType.Info]: 'info_outline'
        };
        this.defaultTimeout = 4000;
        this.defaultClosable = true;
        this.list$ = new BehaviorSubject([]);
        if (!options) {
            throw new Error('No NotificationOptions were received.');
        }
        this.defaultTimeout = options.timeout === undefined ? this.defaultTimeout : options.timeout;
        this.defaultClosable = options.closable === undefined ? this.defaultClosable : options.closable;
        this.defaultTitles = Object.assign(this.defaultTitles, options.titles || {});
        this.defaultIcons = Object.assign(this.defaultIcons, options.icons || {});
    }
    get items() {
        return this.list$;
    }
    success(text, timeout = this.defaultTimeout) {
        this.create({ text, timeout, type: NotificationType.Success });
    }
    error(text, timeout = this.defaultTimeout) {
        this.create({ text, timeout, type: NotificationType.Error });
    }
    warn(text, timeout = this.defaultTimeout) {
        this.create({ text, timeout, type: NotificationType.Warning });
    }
    info(text, timeout = this.defaultTimeout) {
        this.create({ text, timeout, type: NotificationType.Info });
    }
    create(notification) {
        const                  item = this.compose(notification);
        this.push(item);
    }
    transform(callback) {
        const                  oldNotifications = this.list$.getValue();
        const                  newNotifications = callback(oldNotifications);
        this.list$.next(newNotifications);
    }
    delete(notification) {
        return this.pull(notification);
    }
    push(notification) {
        const                  list = this.list$.getValue();
        list.push(notification);
        this.list$.next(list);
    }
    pull(notification) {
        const                  list = this.list$.getValue();
        list.forEach((item, index) => {
            if (item.id === notification.id) {
                list.splice(index, 1);
            }
        });
        this.list$.next(list);
    }
    compose(notification) {
        notification.id = Math.random().toString(36).substr(2, 10);
        notification.closable = notification.closable !== undefined ? notification.closable : this.defaultClosable;
        notification.title = notification.title || this.defaultTitles[notification.type];
        notification.icon = notification.icon || this.defaultIcons[notification.type];
        notification.timeout = notification.timeout !== undefined ? notification.timeout : this.defaultTimeout;
        return notification;
    }
}
NotificationsService.decorators = [
    { type: Injectable },
];
NotificationsService.ctorParameters = () => [
    { type: NotificationOptions, decorators: [{ type: Optional },] },
];

class NgxNotificationsListComponent {
    constructor(notifications) {
        this.notifications = notifications;
        this.trackById = (index, item) => {
            return item.id;
        };
    }
    ngOnInit() {
        this.notifications$ = this.notifications.items;
    }
    onNotificationDestroy(notification) {
        this.notifications.delete(notification);
    }
}
NgxNotificationsListComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-notifications-list',
                template: `<div *ngIf="notifications$ | async as notifications" class="ngx-notifications-wrapper">
    <div [@listAnimation]="notifications.length" class="ngx-notifications-list">
        <div *ngFor="let notification of notifications; trackBy: trackById" class="ngx-notifications-item">
            <ngx-notifications-item [notification]="notification"
                                    (onDestroy)="onNotificationDestroy($event)"></ngx-notifications-item>
        </div>
    </div>
</div>`,
                styles: [`.ngx-notifications-wrapper{
  top:0;
  left:0;
  right:0;
  bottom:0;
  z-index:400;
  position:fixed;
  pointer-events:none; }
.ngx-notifications-list{
  padding:0;
  width:100%;
  display:block;
  max-width:420px;
  margin-left:auto;
  position:relative; }
.ngx-notifications-item{
  margin:0;
  padding:0;
  pointer-events:all; }
`],
                animations: [trigger('listAnimation', [
                        transition('* => *', [
                            query(':enter', style({ opacity: 0 }), { optional: true }),
                            query(':enter', stagger('500ms', [
                                animate('500ms cubic-bezier(0, 0, .2, 1)', keyframes([
                                    style({ opacity: 0, transform: 'translateX(50%)', offset: 0 }),
                                    style({ opacity: 1, transform: 'translateX(0)', offset: 1.0 })
                                ]))
                            ]), { optional: true }),
                            query(':leave', stagger('500ms', [
                                animate('500ms cubic-bezier(0, 0, .2, 1)', keyframes([
                                    style({ height: '*', opacity: 1, transform: 'translateX(0)', offset: 0 }),
                                    style({ height: '*', opacity: 0, transform: 'translateX(-25%)', offset: 0.9 }),
                                    style({ height: 0, opacity: 0, transform: 'translateX(-25%)', offset: 1.0 })
                                ]))
                            ]), { optional: true })
                        ])
                    ])],
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false
            },] },
];
NgxNotificationsListComponent.ctorParameters = () => [
    { type: NotificationsService, },
];

class NgxNotificationsItemComponent {
    constructor(zone, changeDetection) {
        this.zone = zone;
        this.changeDetection = changeDetection;
        this.onDestroy = new EventEmitter();
        this.progress = 0;
        this.count = 0;
        this.instance = () => {
            this.difference = (new Date().getTime() - this.startTime) - (this.count * this.speed);
            if (this.count++ === this.steps) {
                this.onDestroy.emit(this.notification);
            }
            this.progress += 100 / this.steps;
            this.timer = setTimeout(this.instance, (this.speed - this.difference));
            this.zone.run(() => this.changeDetection.detectChanges());
        };
    }
    get progressWidth() {
        return Math.min(this.progress, 100) + '%';
    }
    get notificationClasses() {
        return {
            ['ngx-notification--' + this.notification.type]: true
        };
    }
    get progressBarClasses() {
        return {
            ['ngx-notification-progress--' + this.notification.type]: true
        };
    }
    ngOnInit() {
        if (this.notification.timeout <= 0 || setTimeout === undefined) {
            this.notification.closable = true;
            return;
        }
        this.startTimeout();
    }
    ngOnDestroy() {
        if (this.notification.timeout <= 0 || setTimeout === undefined) {
            return;
        }
        clearTimeout(this.timer);
    }
    startTimeout() {
        this.steps = this.notification.timeout / 10;
        this.speed = this.notification.timeout / this.steps;
        this.startTime = new Date().getTime();
        this.zone.runOutsideAngular(() => this.timer = setTimeout(this.instance, this.speed));
    }
}
NgxNotificationsItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-notifications-item',
                template: `<div [ngClass]="notificationClasses"
     class="ngx-notification">
    <i class="material-icons ngx-notification-icon">{{ notification.icon }}</i>
    <div class="ngx-notification-data">
        <h1 class="ngx-notification-title">{{ notification.title | translate }}</h1>
        <p class="ngx-notification-text">{{ notification.text | translate }}</p>
    </div>
    <div *ngIf="notification.closable"
         (click)="onDestroy.emit(notification)"
         class="ngx-notification-clear">
        <i class="material-icons">clear</i>
    </div>
    <div *ngIf="notification.timeout > 0"
         [ngClass]="progressBarClasses"
         [style.width]="progressWidth"
         class="ngx-notification-progress"></div>
</div>`,
                styles: [`.ngx-notification-icon{
  margin-right:10px; }
.ngx-notification-data{
  width:100%; }
.ngx-notification-title{
  display:block;
  font-size:16px;
  max-width:100%;
  overflow:hidden;
  line-height:1.5;
  white-space:nowrap;
  margin:0 30px 4px 0;
  text-overflow:ellipsis; }
.ngx-notification-text{
  margin:0;
  line-height:1.3;
  color:rgba(255, 255, 255, 0.6); }
.ngx-notification{
  color:white;
  display:-webkit-box;
  display:-ms-flexbox;
  display:flex;
  font-weight:500;
  -webkit-user-select:none;
     -moz-user-select:none;
      -ms-user-select:none;
          user-select:none;
  position:relative;
  border-radius:4px;
  margin:10px 10px 0;
  padding:10px 10px 14px;
  -webkit-box-pack:center;
      -ms-flex-pack:center;
          justify-content:center;
  font-family:'Roboto', sans-serif;
  -webkit-box-shadow:0 1px 2px rgba(0, 0, 0, 0.2);
          box-shadow:0 1px 2px rgba(0, 0, 0, 0.2); }
  .ngx-notification--success{
    background-color:#43a047;
    border-left:4px solid #295f2d; }
  .ngx-notification--error{
    background-color:#be2c2c;
    border-left:4px solid #7e2020; }
  .ngx-notification--warning{
    background-color:#f57f17;
    border-left:4px solid #ac7a26; }
    .ngx-notification--warning .ngx-notification-text{
      color:rgba(0, 0, 0, 0.6); }
  .ngx-notification--info{
    background-color:#5e35b1;
    border-left:4px solid #191b1f; }
.ngx-notification-clear{
  top:0;
  right:0;
  width:30px;
  height:30px;
  margin:5px;
  display:-webkit-box;
  display:-ms-flexbox;
  display:flex;
  cursor:pointer;
  position:absolute;
  border-radius:4px;
  -webkit-box-align:center;
      -ms-flex-align:center;
          align-items:center;
  -webkit-box-pack:center;
      -ms-flex-pack:center;
          justify-content:center;
  -webkit-transition:background-color 200ms cubic-bezier(0, 0, 0.2, 1);
  transition:background-color 200ms cubic-bezier(0, 0, 0.2, 1); }
  .ngx-notification-clear:hover{
    background-color:rgba(0, 0, 0, 0.15); }
  .ngx-notification-clear:active{
    background-color:rgba(0, 0, 0, 0.25); }
.ngx-notification-progress{
  left:0;
  bottom:0;
  height:4px;
  position:absolute;
  background-color:rgba(0, 0, 0, 0.2); }
  .ngx-notification-progress--success{
    background-color:#295f2d; }
  .ngx-notification-progress--error{
    background-color:#7e2020; }
  .ngx-notification-progress--warning{
    background-color:#ac7a26; }
  .ngx-notification-progress--info{
    background-color:#191b1f; }
`],
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false
            },] },
];
NgxNotificationsItemComponent.ctorParameters = () => [
    { type: NgZone, },
    { type: ChangeDetectorRef, },
];
NgxNotificationsItemComponent.propDecorators = {
    "notification": [{ type: Input },],
    "onDestroy": [{ type: Output },],
};

class NgxNotificationsModule {
    static forRoot(options = {}) {
        return {
            ngModule: NgxNotificationsModule,
            providers: [
                NotificationsService,
                { provide: NotificationOptions, useValue: options }
            ]
        };
    }
}
NgxNotificationsModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, NgxTranslationsModule],
                declarations: [NgxNotificationsListComponent, NgxNotificationsItemComponent],
                exports: [NgxNotificationsListComponent]
            },] },
];
NgxNotificationsModule.ctorParameters = () => [];

export { NgxNotificationsModule, NotificationsService, NotificationType, NotificationOptions, NgxNotificationsListComponent, NgxNotificationsItemComponent as ɵa };
//# sourceMappingURL=stanvanheumen-ngx-notifications.js.map
