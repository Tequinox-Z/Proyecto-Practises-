import { __values, __spread } from 'tslib';
import { StorageService, NgxStorageModule } from '@stanvanheumen/ngx-storage';
import { BehaviorSubject } from 'rxjs/BehaviorSubject';
import { Injectable, Optional, Pipe, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';

var TranslationsConfig = /** @class */ (function () {
    function TranslationsConfig() {
        this.production = false;
        this.dictionary = [];
    }
    return TranslationsConfig;
}());
var TranslationsService = /** @class */ (function () {
    function TranslationsService(storage, config) {
        this.storage = storage;
        this.config = config;
        this.storageToken = '__NGX_CURRENT_LANGUAGE__';
        this.dictionary = [];
        this.defaultDictionary = [{ languages: ['en-US', 'en'], data: null, name: 'English (English)' }];
        this.currentLanguage$ = new BehaviorSubject(null);
        if (!this.config) {
            this.config = { production: false, dictionary: [] };
        }
        this.dictionary = this.config.dictionary.concat(this.defaultDictionary);
        if (!this.config.production && !this.validate()) {
            console.warn('The language files have been compared and they have not passed the validation.');
        }
        var language$ = this.storage ? (this.storage.get(this.storageToken)) : new BehaviorSubject(null);
        var language = language$.getValue();
        var verifiedLanguage = this.verify(language);
        this.use(verifiedLanguage);
    }
    TranslationsService.prototype.use = function (language) {
        if (!this.isLanguageSupported(language)) {
            language = this.defaultDictionary[0].languages[0];
            console.warn("The language is not supported; The language has been set to '" + language + "'");
        }
        this.currentLanguage$.next(language);
        if (this.storage) {
            this.storage.set(this.storageToken, language);
        }
    };
    TranslationsService.prototype.instant = function (data) {
        return this.translate(data);
    };
    TranslationsService.prototype.translate = function (item) {
        var _this = this;
        var dictionary = this.getLanguageDictionary(this.currentLanguage$.getValue());
        var token = typeof item === 'object' ? item.token : item;
        var data = typeof item === 'object' ? item.data : {};
        var sentence = null;
        if (dictionary) {
            if (!dictionary[token]) {
                this.notify("Key '" + token + "' was not found; " + token + " was returned.");
                sentence = token;
            }
            else {
                sentence = dictionary[token];
            }
        }
        else {
            sentence = token;
        }
        (sentence.match(/\${(.*?)}/g) || []).forEach(function (match) {
            var key = match.replace(/[${} ]/g, '');
            var words = key.split('|');
            if (words.length <= 0 || words.length > 2) {
                return;
            }
            var word = words[0];
            if (data[word]) {
                word = data[word];
                if (words.length === 1 || (words[1] && words[1].split(',').indexOf('keep') === -1)) {
                    word = _this.translate(word);
                }
            }
            if (words.length === 2) {
                var actions = words[1].split(',');
                actions.forEach(function (action) {
                    if (action === 'lowercase') {
                        word = word.toLowerCase();
                    }
                    else if (action === 'uppercase') {
                        word = word.toUpperCase();
                    }
                    else if (action === 'ucfirst') {
                        var character = word.charAt(0).toUpperCase();
                        word = character + word.substr(1);
                    }
                });
            }
            sentence = sentence.replace(match, word);
        });
        return sentence;
    };
    TranslationsService.prototype.getLanguage = function () {
        return this.currentLanguage$.getValue();
    };
    TranslationsService.prototype.getDictionary = function () {
        return this.dictionary;
    };
    TranslationsService.prototype.verify = function (language) {
        if (language !== null && this.isLanguageSupported(language)) {
            return language;
        }
        var browserLanguage = this.getBrowserLanguage();
        if (!this.isLanguageSupported(browserLanguage)) {
            browserLanguage = this.defaultDictionary[0].languages[0];
        }
        if (this.storage) {
            this.storage.set(this.storageToken, browserLanguage);
        }
        return browserLanguage;
    };
    TranslationsService.prototype.getBrowserLanguage = function () {
        var language = null;
        if (!navigator) {
            return language;
        }
        if (navigator.languages && navigator.languages.length) {
            language = navigator.languages[0];
        }
        else if (navigator['userLanguage']) {
            language = navigator['userLanguage'];
        }
        else {
            language = navigator.language;
        }
        return language;
    };
    TranslationsService.prototype.getLanguageDictionary = function (language) {
        try {
            for (var _a = __values(this.dictionary), _b = _a.next(); !_b.done; _b = _a.next()) {
                var item = _b.value;
                if (item.languages.indexOf(language) > -1) {
                    return item.data;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return null;
        var e_1, _c;
    };
    TranslationsService.prototype.isLanguageSupported = function (language) {
        try {
            for (var _a = __values(this.dictionary), _b = _a.next(); !_b.done; _b = _a.next()) {
                var item = _b.value;
                if (item.languages.indexOf(language) > -1) {
                    return true;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return false;
        var e_2, _c;
    };
    TranslationsService.prototype.validate = function () {
        var _this = this;
        var array = [];
        this.dictionary.forEach(function (language) {
            if (!language.data) {
                return;
            }
            var data = _this.getKeys(language.data);
            array.push(data);
        });
        var first = array[0] || [];
        return array.every(function (element) { return _this.compare(first, element); });
    };
    TranslationsService.prototype.getKeys = function (object, identifier) {
        var _this = this;
        if (identifier === void 0) { identifier = null; }
        var result = [];
        Object.keys(object).forEach(function (key) {
            var item = object[key];
            if (typeof item === 'object') {
                result.push.apply(result, __spread(_this.getKeys(item, identifier ? (identifier + '.' + key) : key)));
            }
            else {
                result.push(identifier ? (identifier + '.' + key) : key);
            }
        });
        return result;
    };
    TranslationsService.prototype.compare = function (first, second) {
        if (first === second) {
            return true;
        }
        if (first === null || second === null) {
            return false;
        }
        var isValid = true;
        if (first.length !== second.length) {
            console.warn('The files have been compared and not every file has the same length.');
            isValid = false;
        }
        for (var index = 0; index < first.length; ++index) {
            if (first[index] !== second[index]) {
                isValid = false;
                console.warn("Line " + index + " did not equal the first language.json file; " + first[index] + " !== " + second[index]);
            }
        }
        return isValid;
    };
    TranslationsService.prototype.notify = function (message) {
        if (this.config && this.config.production) {
            console.warn(message);
            return;
        }
        throw new Error(message);
    };
    return TranslationsService;
}());
TranslationsService.decorators = [
    { type: Injectable },
];
TranslationsService.ctorParameters = function () { return [
    { type: StorageService, },
    { type: TranslationsConfig, decorators: [{ type: Optional },] },
]; };
var NgxTranslationsPipe = /** @class */ (function () {
    function NgxTranslationsPipe(translate) {
        this.translate = translate;
    }
    NgxTranslationsPipe.prototype.transform = function (value, args) {
        if (args === void 0) { args = {}; }
        if (!this.translate) {
            return value;
        }
        if (!value) {
            return null;
        }
        if (typeof args !== 'object') {
            throw new Error('The arguments were not formatted properly.');
        }
        if (typeof value === 'string') {
            value = { token: value, data: args };
        }
        return this.translate.instant(value);
    };
    return NgxTranslationsPipe;
}());
NgxTranslationsPipe.decorators = [
    { type: Pipe, args: [{
                name: 'translate'
            },] },
];
NgxTranslationsPipe.ctorParameters = function () { return [
    { type: TranslationsService, decorators: [{ type: Optional },] },
]; };
var NgxTranslationsModule = /** @class */ (function () {
    function NgxTranslationsModule() {
    }
    NgxTranslationsModule.forRoot = function (config) {
        if (config === void 0) { config = { production: false, dictionary: [] }; }
        return {
            ngModule: NgxTranslationsModule,
            providers: [
                { provide: TranslationsConfig, useValue: config }
            ]
        };
    };
    return NgxTranslationsModule;
}());
NgxTranslationsModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, NgxStorageModule],
                providers: [TranslationsService],
                declarations: [NgxTranslationsPipe],
                exports: [NgxTranslationsPipe]
            },] },
];
NgxTranslationsModule.ctorParameters = function () { return []; };

export { NgxTranslationsModule, TranslationsService, NgxTranslationsPipe, TranslationsConfig };
//# sourceMappingURL=stanvanheumen-ngx-translations.js.map
