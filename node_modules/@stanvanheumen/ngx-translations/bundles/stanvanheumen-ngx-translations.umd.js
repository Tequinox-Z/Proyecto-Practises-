(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@stanvanheumen/ngx-storage'), require('rxjs/BehaviorSubject'), require('@angular/core'), require('@angular/common')) :
	typeof define === 'function' && define.amd ? define(['exports', '@stanvanheumen/ngx-storage', 'rxjs/BehaviorSubject', '@angular/core', '@angular/common'], factory) :
	(factory((global.stanvanheumen = global.stanvanheumen || {}, global.stanvanheumen['ngx-translations'] = {}),global.ngxStorage,global.Rx,global.ng.core,global.ng.common));
}(this, (function (exports,ngxStorage,BehaviorSubject,core,common) { 'use strict';

function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}
function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}
function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

var TranslationsConfig =               (function () {
    function TranslationsConfig() {
        this.production = false;
        this.dictionary = [];
    }
    return TranslationsConfig;
}());
var TranslationsService =               (function () {
    function TranslationsService(storage, config) {
        this.storage = storage;
        this.config = config;
        this.storageToken = '__NGX_CURRENT_LANGUAGE__';
        this.dictionary = [];
        this.defaultDictionary = [{ languages: ['en-US', 'en'], data: null, name: 'English (English)' }];
        this.currentLanguage$ = new BehaviorSubject.BehaviorSubject(null);
        if (!this.config) {
            this.config = { production: false, dictionary: [] };
        }
        this.dictionary = this.config.dictionary.concat(this.defaultDictionary);
        if (!this.config.production && !this.validate()) {
            console.warn('The language files have been compared and they have not passed the validation.');
        }
        var language$ = this.storage ? (this.storage.get(this.storageToken)) : new BehaviorSubject.BehaviorSubject(null);
        var language = language$.getValue();
        var verifiedLanguage = this.verify(language);
        this.use(verifiedLanguage);
    }
    TranslationsService.prototype.use = function (language) {
        if (!this.isLanguageSupported(language)) {
            language = this.defaultDictionary[0].languages[0];
            console.warn("The language is not supported; The language has been set to '" + language + "'");
        }
        this.currentLanguage$.next(language);
        if (this.storage) {
            this.storage.set(this.storageToken, language);
        }
    };
    TranslationsService.prototype.instant = function (data) {
        return this.translate(data);
    };
    TranslationsService.prototype.translate = function (item) {
        var _this = this;
        var dictionary = this.getLanguageDictionary(this.currentLanguage$.getValue());
        var token = typeof item === 'object' ? item.token : item;
        var data = typeof item === 'object' ? item.data : {};
        var sentence = null;
        if (dictionary) {
            if (!dictionary[token]) {
                this.notify("Key '" + token + "' was not found; " + token + " was returned.");
                sentence = token;
            }
            else {
                sentence = dictionary[token];
            }
        }
        else {
            sentence = token;
        }
        (sentence.match(/\${(.*?)}/g) || []).forEach(function (match) {
            var key = match.replace(/[${} ]/g, '');
            var words = key.split('|');
            if (words.length <= 0 || words.length > 2) {
                return;
            }
            var word = words[0];
            if (data[word]) {
                word = data[word];
                if (words.length === 1 || (words[1] && words[1].split(',').indexOf('keep') === -1)) {
                    word = _this.translate(word);
                }
            }
            if (words.length === 2) {
                var actions = words[1].split(',');
                actions.forEach(function (action) {
                    if (action === 'lowercase') {
                        word = word.toLowerCase();
                    }
                    else if (action === 'uppercase') {
                        word = word.toUpperCase();
                    }
                    else if (action === 'ucfirst') {
                        var character = word.charAt(0).toUpperCase();
                        word = character + word.substr(1);
                    }
                });
            }
            sentence = sentence.replace(match, word);
        });
        return sentence;
    };
    TranslationsService.prototype.getLanguage = function () {
        return this.currentLanguage$.getValue();
    };
    TranslationsService.prototype.getDictionary = function () {
        return this.dictionary;
    };
    TranslationsService.prototype.verify = function (language) {
        if (language !== null && this.isLanguageSupported(language)) {
            return language;
        }
        var browserLanguage = this.getBrowserLanguage();
        if (!this.isLanguageSupported(browserLanguage)) {
            browserLanguage = this.defaultDictionary[0].languages[0];
        }
        if (this.storage) {
            this.storage.set(this.storageToken, browserLanguage);
        }
        return browserLanguage;
    };
    TranslationsService.prototype.getBrowserLanguage = function () {
        var language = null;
        if (!navigator) {
            return language;
        }
        if (navigator.languages && navigator.languages.length) {
            language = navigator.languages[0];
        }
        else if (navigator['userLanguage']) {
            language = navigator['userLanguage'];
        }
        else {
            language = navigator.language;
        }
        return language;
    };
    TranslationsService.prototype.getLanguageDictionary = function (language) {
        try {
            for (var _a = __values(this.dictionary), _b = _a.next(); !_b.done; _b = _a.next()) {
                var item = _b.value;
                if (item.languages.indexOf(language) > -1) {
                    return item.data;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return null;
        var e_1, _c;
    };
    TranslationsService.prototype.isLanguageSupported = function (language) {
        try {
            for (var _a = __values(this.dictionary), _b = _a.next(); !_b.done; _b = _a.next()) {
                var item = _b.value;
                if (item.languages.indexOf(language) > -1) {
                    return true;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return false;
        var e_2, _c;
    };
    TranslationsService.prototype.validate = function () {
        var _this = this;
        var array = [];
        this.dictionary.forEach(function (language) {
            if (!language.data) {
                return;
            }
            var data = _this.getKeys(language.data);
            array.push(data);
        });
        var first = array[0] || [];
        return array.every(function (element) { return _this.compare(first, element); });
    };
    TranslationsService.prototype.getKeys = function (object, identifier) {
        var _this = this;
        if (identifier === void 0) { identifier = null; }
        var result = [];
        Object.keys(object).forEach(function (key) {
            var item = object[key];
            if (typeof item === 'object') {
                result.push.apply(result, __spread(_this.getKeys(item, identifier ? (identifier + '.' + key) : key)));
            }
            else {
                result.push(identifier ? (identifier + '.' + key) : key);
            }
        });
        return result;
    };
    TranslationsService.prototype.compare = function (first, second) {
        if (first === second) {
            return true;
        }
        if (first === null || second === null) {
            return false;
        }
        var isValid = true;
        if (first.length !== second.length) {
            console.warn('The files have been compared and not every file has the same length.');
            isValid = false;
        }
        for (var index = 0; index < first.length; ++index) {
            if (first[index] !== second[index]) {
                isValid = false;
                console.warn("Line " + index + " did not equal the first language.json file; " + first[index] + " !== " + second[index]);
            }
        }
        return isValid;
    };
    TranslationsService.prototype.notify = function (message) {
        if (this.config && this.config.production) {
            console.warn(message);
            return;
        }
        throw new Error(message);
    };
    return TranslationsService;
}());
TranslationsService.decorators = [
    { type: core.Injectable },
];
TranslationsService.ctorParameters = function () { return [
    { type: ngxStorage.StorageService, },
    { type: TranslationsConfig, decorators: [{ type: core.Optional },] },
]; };
var NgxTranslationsPipe =               (function () {
    function NgxTranslationsPipe(translate) {
        this.translate = translate;
    }
    NgxTranslationsPipe.prototype.transform = function (value, args) {
        if (args === void 0) { args = {}; }
        if (!this.translate) {
            return value;
        }
        if (!value) {
            return null;
        }
        if (typeof args !== 'object') {
            throw new Error('The arguments were not formatted properly.');
        }
        if (typeof value === 'string') {
            value = { token: value, data: args };
        }
        return this.translate.instant(value);
    };
    return NgxTranslationsPipe;
}());
NgxTranslationsPipe.decorators = [
    { type: core.Pipe, args: [{
                name: 'translate'
            },] },
];
NgxTranslationsPipe.ctorParameters = function () { return [
    { type: TranslationsService, decorators: [{ type: core.Optional },] },
]; };
var NgxTranslationsModule =               (function () {
    function NgxTranslationsModule() {
    }
    NgxTranslationsModule.forRoot = function (config) {
        if (config === void 0) { config = { production: false, dictionary: [] }; }
        return {
            ngModule: NgxTranslationsModule,
            providers: [
                { provide: TranslationsConfig, useValue: config }
            ]
        };
    };
    return NgxTranslationsModule;
}());
NgxTranslationsModule.decorators = [
    { type: core.NgModule, args: [{
                imports: [common.CommonModule, ngxStorage.NgxStorageModule],
                providers: [TranslationsService],
                declarations: [NgxTranslationsPipe],
                exports: [NgxTranslationsPipe]
            },] },
];
NgxTranslationsModule.ctorParameters = function () { return []; };

exports.NgxTranslationsModule = NgxTranslationsModule;
exports.TranslationsService = TranslationsService;
exports.NgxTranslationsPipe = NgxTranslationsPipe;
exports.TranslationsConfig = TranslationsConfig;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=stanvanheumen-ngx-translations.umd.js.map
