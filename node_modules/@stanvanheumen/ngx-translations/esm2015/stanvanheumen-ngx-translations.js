import { StorageService, NgxStorageModule } from '@stanvanheumen/ngx-storage';
import { BehaviorSubject } from 'rxjs/BehaviorSubject';
import { Injectable, Optional, Pipe, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';

class TranslationsConfig {
    constructor() {
        this.production = false;
        this.dictionary = [];
    }
}

class TranslationsService {
    constructor(storage, config) {
        this.storage = storage;
        this.config = config;
        this.storageToken = '__NGX_CURRENT_LANGUAGE__';
        this.dictionary = [];
        this.defaultDictionary = [{ languages: ['en-US', 'en'], data: null, name: 'English (English)' }];
        this.currentLanguage$ = new BehaviorSubject(null);
        if (!this.config) {
            this.config = { production: false, dictionary: [] };
        }
        this.dictionary = this.config.dictionary.concat(this.defaultDictionary);
        if (!this.config.production && !this.validate()) {
            console.warn('The language files have been compared and they have not passed the validation.');
        }
        const                  language$ = this.storage ?                  (this.storage.get(this.storageToken)) : new BehaviorSubject(null);
        const                  language = language$.getValue();
        const                  verifiedLanguage = this.verify(language);
        this.use(verifiedLanguage);
    }
    use(language) {
        if (!this.isLanguageSupported(language)) {
            language = this.defaultDictionary[0].languages[0];
            console.warn(`The language is not supported; The language has been set to '${language}'`);
        }
        this.currentLanguage$.next(language);
        if (this.storage) {
            this.storage.set(this.storageToken, language);
        }
    }
    instant(data) {
        return this.translate(data);
    }
    translate(item) {
        const                  dictionary = this.getLanguageDictionary(this.currentLanguage$.getValue());
        const                  token = typeof item === 'object' ? item.token : item;
        const                  data = typeof item === 'object' ? item.data : {};
        let                  sentence = null;
        if (dictionary) {
            if (!dictionary[token]) {
                this.notify(`Key '${token}' was not found; ${token} was returned.`);
                sentence = token;
            }
            else {
                sentence = dictionary[token];
            }
        }
        else {
            sentence = token;
        }
        (sentence.match(/\${(.*?)}/g) || []).forEach(match => {
            const                  key = match.replace(/[${} ]/g, '');
            const                  words = key.split('|');
            if (words.length <= 0 || words.length > 2) {
                return;
            }
            let                  word = words[0];
            if (data[word]) {
                word = data[word];
                if (words.length === 1 || (words[1] && words[1].split(',').indexOf('keep') === -1)) {
                    word = this.translate(word);
                }
            }
            if (words.length === 2) {
                const                  actions = words[1].split(',');
                actions.forEach(action => {
                    if (action === 'lowercase') {
                        word = word.toLowerCase();
                    }
                    else if (action === 'uppercase') {
                        word = word.toUpperCase();
                    }
                    else if (action === 'ucfirst') {
                        const                  character = word.charAt(0).toUpperCase();
                        word = character + word.substr(1);
                    }
                });
            }
            sentence = sentence.replace(match, word);
        });
        return sentence;
    }
    getLanguage() {
        return this.currentLanguage$.getValue();
    }
    getDictionary() {
        return this.dictionary;
    }
    verify(language) {
        if (language !== null && this.isLanguageSupported(language)) {
            return language;
        }
        let                  browserLanguage = this.getBrowserLanguage();
        if (!this.isLanguageSupported(browserLanguage)) {
            browserLanguage = this.defaultDictionary[0].languages[0];
        }
        if (this.storage) {
            this.storage.set(this.storageToken, browserLanguage);
        }
        return browserLanguage;
    }
    getBrowserLanguage() {
        let                  language = null;
        if (!navigator) {
            return language;
        }
        if (navigator.languages && navigator.languages.length) {
            language = navigator.languages[0];
        }
        else if (navigator['userLanguage']) {
            language = navigator['userLanguage'];
        }
        else {
            language = navigator.language;
        }
        return language;
    }
    getLanguageDictionary(language) {
        for (let                  item of this.dictionary) {
            if (item.languages.indexOf(language) > -1) {
                return item.data;
            }
        }
        return null;
    }
    isLanguageSupported(language) {
        for (let                  item of this.dictionary) {
            if (item.languages.indexOf(language) > -1) {
                return true;
            }
        }
        return false;
    }
    validate() {
        const                  array = [];
        this.dictionary.forEach(language => {
            if (!language.data) {
                return;
            }
            const                  data = this.getKeys(language.data);
            array.push(data);
        });
        const                  first = array[0] || [];
        return array.every(element => this.compare(first, element));
    }
    getKeys(object, identifier = null) {
        const                  result = [];
        Object.keys(object).forEach(key => {
            const                  item = object[key];
            if (typeof item === 'object') {
                result.push(...this.getKeys(item, identifier ? (identifier + '.' + key) : key));
            }
            else {
                result.push(identifier ? (identifier + '.' + key) : key);
            }
        });
        return result;
    }
    compare(first, second) {
        if (first === second) {
            return true;
        }
        if (first === null || second === null) {
            return false;
        }
        let                  isValid = true;
        if (first.length !== second.length) {
            console.warn('The files have been compared and not every file has the same length.');
            isValid = false;
        }
        for (let                  index = 0; index < first.length; ++index) {
            if (first[index] !== second[index]) {
                isValid = false;
                console.warn(`Line ${index} did not equal the first language.json file; ${first[index]} !== ${second[index]}`);
            }
        }
        return isValid;
    }
    notify(message) {
        if (this.config && this.config.production) {
            console.warn(message);
            return;
        }
        throw new Error(message);
    }
}
TranslationsService.decorators = [
    { type: Injectable },
];
TranslationsService.ctorParameters = () => [
    { type: StorageService, },
    { type: TranslationsConfig, decorators: [{ type: Optional },] },
];

class NgxTranslationsPipe {
    constructor(translate) {
        this.translate = translate;
    }
    transform(value, args = {}) {
        if (!this.translate) {
            return value;
        }
        if (!value) {
            return null;
        }
        if (typeof args !== 'object') {
            throw new Error('The arguments were not formatted properly.');
        }
        if (typeof value === 'string') {
            value = { token: value, data: args };
        }
        return this.translate.instant(value);
    }
}
NgxTranslationsPipe.decorators = [
    { type: Pipe, args: [{
                name: 'translate'
            },] },
];
NgxTranslationsPipe.ctorParameters = () => [
    { type: TranslationsService, decorators: [{ type: Optional },] },
];

class NgxTranslationsModule {
    static forRoot(config = { production: false, dictionary: [] }) {
        return {
            ngModule: NgxTranslationsModule,
            providers: [
                { provide: TranslationsConfig, useValue: config }
            ]
        };
    }
}
NgxTranslationsModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, NgxStorageModule],
                providers: [TranslationsService],
                declarations: [NgxTranslationsPipe],
                exports: [NgxTranslationsPipe]
            },] },
];
NgxTranslationsModule.ctorParameters = () => [];

export { NgxTranslationsModule, TranslationsService, NgxTranslationsPipe, TranslationsConfig };
//# sourceMappingURL=stanvanheumen-ngx-translations.js.map
